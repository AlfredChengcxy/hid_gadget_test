{"name":"HID Gadget Test","tagline":"Linux USB HID Gadget Test Application","body":"\r\n##\t\t     Linux USB HID gadget driver\r\n\r\n[![Build Status](https://travis-ci.org/aagallag/hid_gadget_test.svg?branch=master)](https://travis-ci.org/aagallag/hid_gadget_test)\r\n\r\n###Introduction\r\n\r\n\tThe HID Gadget driver provides emulation of USB Human Interface\r\n\tDevices (HID). The basic HID handling is done in the kernel,\r\n\tand HID reports can be sent/received through I/O on the\r\n\t/dev/hidgX character devices.\r\n\r\n\tFor more details about HID, see the developer page on\r\n\thttp://www.usb.org/developers/hidpage/\r\n\r\n###Configuration\r\n\r\n\tg_hid is a platform driver, so to use it you need to add\r\n\tstruct platform_device(s) to your platform code defining the\r\n\tHID function descriptors you want to use - E.G. something\r\n\tlike:\r\n\r\n```c\r\n#include <linux/platform_device.h>\r\n#include <linux/usb/g_hid.h>\r\n\r\n/* hid descriptor for a keyboard */\r\nstatic struct hidg_func_descriptor my_hid_data = {\r\n\t.subclass\t\t= 0, /* No subclass */\r\n\t.protocol\t\t= 1, /* Keyboard */\r\n\t.report_length\t\t= 8,\r\n\t.report_desc_length\t= 63,\r\n\t.report_desc\t\t= {\r\n\t\t0x05, 0x01,\t/* USAGE_PAGE (Generic Desktop)\t          */\r\n\t\t0x09, 0x06,\t/* USAGE (Keyboard)                       */\r\n\t\t0xa1, 0x01,\t/* COLLECTION (Application)               */\r\n\t\t0x05, 0x07,\t/*   USAGE_PAGE (Keyboard)                */\r\n\t\t0x19, 0xe0,\t/*   USAGE_MINIMUM (Keyboard LeftControl) */\r\n\t\t0x29, 0xe7,\t/*   USAGE_MAXIMUM (Keyboard Right GUI)   */\r\n\t\t0x15, 0x00,\t/*   LOGICAL_MINIMUM (0)                  */\r\n\t\t0x25, 0x01,\t/*   LOGICAL_MAXIMUM (1)                  */\r\n\t\t0x75, 0x01,\t/*   REPORT_SIZE (1)                      */\r\n\t\t0x95, 0x08,\t/*   REPORT_COUNT (8)                     */\r\n\t\t0x81, 0x02,\t/*   INPUT (Data,Var,Abs)                 */\r\n\t\t0x95, 0x01,\t/*   REPORT_COUNT (1)                     */\r\n\t\t0x75, 0x08,\t/*   REPORT_SIZE (8)                      */\r\n\t\t0x81, 0x03,\t/*   INPUT (Cnst,Var,Abs)                 */\r\n\t\t0x95, 0x05,\t/*   REPORT_COUNT (5)                     */\r\n\t\t0x75, 0x01,\t/*   REPORT_SIZE (1)                      */\r\n\t\t0x05, 0x08,\t/*   USAGE_PAGE (LEDs)                    */\r\n\t\t0x19, 0x01,\t/*   USAGE_MINIMUM (Num Lock)             */\r\n\t\t0x29, 0x05,\t/*   USAGE_MAXIMUM (Kana)                 */\r\n\t\t0x91, 0x02,\t/*   OUTPUT (Data,Var,Abs)                */\r\n\t\t0x95, 0x01,\t/*   REPORT_COUNT (1)                     */\r\n\t\t0x75, 0x03,\t/*   REPORT_SIZE (3)                      */\r\n\t\t0x91, 0x03,\t/*   OUTPUT (Cnst,Var,Abs)                */\r\n\t\t0x95, 0x06,\t/*   REPORT_COUNT (6)                     */\r\n\t\t0x75, 0x08,\t/*   REPORT_SIZE (8)                      */\r\n\t\t0x15, 0x00,\t/*   LOGICAL_MINIMUM (0)                  */\r\n\t\t0x25, 0x65,\t/*   LOGICAL_MAXIMUM (101)                */\r\n\t\t0x05, 0x07,\t/*   USAGE_PAGE (Keyboard)                */\r\n\t\t0x19, 0x00,\t/*   USAGE_MINIMUM (Reserved)             */\r\n\t\t0x29, 0x65,\t/*   USAGE_MAXIMUM (Keyboard Application) */\r\n\t\t0x81, 0x00,\t/*   INPUT (Data,Ary,Abs)                 */\r\n\t\t0xc0\t\t/* END_COLLECTION                         */\r\n\t}\r\n};\r\n\r\nstatic struct platform_device my_hid = {\r\n\t.name\t\t\t= \"hidg\",\r\n\t.id\t\t\t= 0,\r\n\t.num_resources\t\t= 0,\r\n\t.resource\t\t= 0,\r\n\t.dev.platform_data\t= &my_hid_data,\r\n};\r\n```\r\n\r\n\tYou can add as many HID functions as you want, only limited by\r\n\tthe amount of interrupt endpoints your gadget driver supports.\r\n\r\n###Configuration with configfs\r\n\r\n\tInstead of adding fake platform devices and drivers in order to pass\r\n\tsome data to the kernel, if HID is a part of a gadget composed with\r\n\tconfigfs the hidg_func_descriptor.report_desc is passed to the kernel\r\n\tby writing the appropriate stream of bytes to a configfs attribute.\r\n\r\n###Send and receive HID reports\r\n\r\n\tHID reports can be sent/received using read/write on the\r\n\t/dev/hidgX character devices. See below for an example program\r\n\tto do this.\r\n\r\n\thid_gadget_test is a small interactive program to test the HID\r\n\tgadget driver. To use, point it at a hidg device and set the\r\n\tdevice type (keyboard / mouse / joystick) - E.G.:\r\n\r\n\t\t# hid_gadget_test /dev/hidg0 keyboard\r\n\r\n\tYou are now in the prompt of hid_gadget_test. You can type any\r\n\tcombination of options and values. Available options and\r\n\tvalues are listed at program start. In keyboard mode you can\r\n\tsend up to six values.\r\n\r\n\tFor example type: g i s t r --left-shift\r\n\r\n\tHit return and the corresponding report will be sent by the\r\n\tHID gadget.\r\n\r\n\tAnother interesting example is the caps lock test. Type\r\n\t--caps-lock and hit return. A report is then sent by the\r\n\tgadget and you should receive the host answer, corresponding\r\n\tto the caps lock LED status.\r\n\r\n\t\t--caps-lock\r\n\t\trecv report:2\r\n\r\n\tWith this command:\r\n\r\n\t\t# hid_gadget_test /dev/hidg1 mouse\r\n\r\n\tYou can test the mouse emulation. Values are two signed numbers.\r\n\r\n\r\n###Sample code\r\n```c\r\n/* hid_gadget_test */\r\n\r\n#include <pthread.h>\r\n#include <string.h>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <fcntl.h>\r\n#include <errno.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\n#define BUF_LEN 512\r\n\r\nstruct options {\r\n\tconst char    *opt;\r\n\tunsigned char val;\r\n};\r\n\r\nstatic struct options kmod[] = {\r\n\t{.opt = \"--left-ctrl\",\t\t.val = 0x01},\r\n\t{.opt = \"--right-ctrl\",\t\t.val = 0x10},\r\n\t{.opt = \"--left-shift\",\t\t.val = 0x02},\r\n\t{.opt = \"--right-shift\",\t.val = 0x20},\r\n\t{.opt = \"--left-alt\",\t\t.val = 0x04},\r\n\t{.opt = \"--right-alt\",\t\t.val = 0x40},\r\n\t{.opt = \"--left-meta\",\t\t.val = 0x08},\r\n\t{.opt = \"--right-meta\",\t\t.val = 0x80},\r\n\t{.opt = NULL}\r\n};\r\n\r\nstatic struct options kval[] = {\r\n\t{.opt = \"--return\",\t.val = 0x28},\r\n\t{.opt = \"--esc\",\t.val = 0x29},\r\n\t{.opt = \"--bckspc\",\t.val = 0x2a},\r\n\t{.opt = \"--tab\",\t.val = 0x2b},\r\n\t{.opt = \"--spacebar\",\t.val = 0x2c},\r\n\t{.opt = \"--caps-lock\",\t.val = 0x39},\r\n\t{.opt = \"--f1\",\t\t.val = 0x3a},\r\n\t{.opt = \"--f2\",\t\t.val = 0x3b},\r\n\t{.opt = \"--f3\",\t\t.val = 0x3c},\r\n\t{.opt = \"--f4\",\t\t.val = 0x3d},\r\n\t{.opt = \"--f5\",\t\t.val = 0x3e},\r\n\t{.opt = \"--f6\",\t\t.val = 0x3f},\r\n\t{.opt = \"--f7\",\t\t.val = 0x40},\r\n\t{.opt = \"--f8\",\t\t.val = 0x41},\r\n\t{.opt = \"--f9\",\t\t.val = 0x42},\r\n\t{.opt = \"--f10\",\t.val = 0x43},\r\n\t{.opt = \"--f11\",\t.val = 0x44},\r\n\t{.opt = \"--f12\",\t.val = 0x45},\r\n\t{.opt = \"--insert\",\t.val = 0x49},\r\n\t{.opt = \"--home\",\t.val = 0x4a},\r\n\t{.opt = \"--pageup\",\t.val = 0x4b},\r\n\t{.opt = \"--del\",\t.val = 0x4c},\r\n\t{.opt = \"--end\",\t.val = 0x4d},\r\n\t{.opt = \"--pagedown\",\t.val = 0x4e},\r\n\t{.opt = \"--right\",\t.val = 0x4f},\r\n\t{.opt = \"--left\",\t.val = 0x50},\r\n\t{.opt = \"--down\",\t.val = 0x51},\r\n\t{.opt = \"--kp-enter\",\t.val = 0x58},\r\n\t{.opt = \"--up\",\t\t.val = 0x52},\r\n\t{.opt = \"--num-lock\",\t.val = 0x53},\r\n\t{.opt = NULL}\r\n};\r\n\r\nint keyboard_fill_report(char report[8], char buf[BUF_LEN], int *hold)\r\n{\r\n\tchar *tok = strtok(buf, \" \");\r\n\tint key = 0;\r\n\tint i = 0;\r\n\r\n\tfor (; tok != NULL; tok = strtok(NULL, \" \")) {\r\n\r\n\t\tif (strcmp(tok, \"--quit\") == 0)\r\n\t\t\treturn -1;\r\n\r\n\t\tif (strcmp(tok, \"--hold\") == 0) {\r\n\t\t\t*hold = 1;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (key < 6) {\r\n\t\t\tfor (i = 0; kval[i].opt != NULL; i++)\r\n\t\t\t\tif (strcmp(tok, kval[i].opt) == 0) {\r\n\t\t\t\t\treport[2 + key++] = kval[i].val;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\tif (kval[i].opt != NULL)\r\n\t\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (key < 6)\r\n\t\t\tif (islower(tok[0])) {\r\n\t\t\t\treport[2 + key++] = (tok[0] - ('a' - 0x04));\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\tfor (i = 0; kmod[i].opt != NULL; i++)\r\n\t\t\tif (strcmp(tok, kmod[i].opt) == 0) {\r\n\t\t\t\treport[0] = report[0] | kmod[i].val;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tif (kmod[i].opt != NULL)\r\n\t\t\tcontinue;\r\n\r\n\t\tif (key < 6)\r\n\t\t\tfprintf(stderr, \"unknown option: %s\\n\", tok);\r\n\t}\r\n\treturn 8;\r\n}\r\n\r\nstatic struct options mmod[] = {\r\n\t{.opt = \"--b1\", .val = 0x01},\r\n\t{.opt = \"--b2\", .val = 0x02},\r\n\t{.opt = \"--b3\", .val = 0x04},\r\n\t{.opt = NULL}\r\n};\r\n\r\nint mouse_fill_report(char report[8], char buf[BUF_LEN], int *hold)\r\n{\r\n\tchar *tok = strtok(buf, \" \");\r\n\tint mvt = 0;\r\n\tint i = 0;\r\n\tfor (; tok != NULL; tok = strtok(NULL, \" \")) {\r\n\r\n\t\tif (strcmp(tok, \"--quit\") == 0)\r\n\t\t\treturn -1;\r\n\r\n\t\tif (strcmp(tok, \"--hold\") == 0) {\r\n\t\t\t*hold = 1;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tfor (i = 0; mmod[i].opt != NULL; i++)\r\n\t\t\tif (strcmp(tok, mmod[i].opt) == 0) {\r\n\t\t\t\treport[0] = report[0] | mmod[i].val;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tif (mmod[i].opt != NULL)\r\n\t\t\tcontinue;\r\n\r\n\t\tif (!(tok[0] == '-' && tok[1] == '-') && mvt < 2) {\r\n\t\t\terrno = 0;\r\n\t\t\treport[1 + mvt++] = (char)strtol(tok, NULL, 0);\r\n\t\t\tif (errno != 0) {\r\n\t\t\t\tfprintf(stderr, \"Bad value:'%s'\\n\", tok);\r\n\t\t\t\treport[1 + mvt--] = 0;\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tfprintf(stderr, \"unknown option: %s\\n\", tok);\r\n\t}\r\n\treturn 3;\r\n}\r\n\r\nstatic struct options jmod[] = {\r\n\t{.opt = \"--b1\",\t\t.val = 0x10},\r\n\t{.opt = \"--b2\",\t\t.val = 0x20},\r\n\t{.opt = \"--b3\",\t\t.val = 0x40},\r\n\t{.opt = \"--b4\",\t\t.val = 0x80},\r\n\t{.opt = \"--hat1\",\t.val = 0x00},\r\n\t{.opt = \"--hat2\",\t.val = 0x01},\r\n\t{.opt = \"--hat3\",\t.val = 0x02},\r\n\t{.opt = \"--hat4\",\t.val = 0x03},\r\n\t{.opt = \"--hatneutral\",\t.val = 0x04},\r\n\t{.opt = NULL}\r\n};\r\n\r\nint joystick_fill_report(char report[8], char buf[BUF_LEN], int *hold)\r\n{\r\n\tchar *tok = strtok(buf, \" \");\r\n\tint mvt = 0;\r\n\tint i = 0;\r\n\r\n\t*hold = 1;\r\n\r\n\t/* set default hat position: neutral */\r\n\treport[3] = 0x04;\r\n\r\n\tfor (; tok != NULL; tok = strtok(NULL, \" \")) {\r\n\r\n\t\tif (strcmp(tok, \"--quit\") == 0)\r\n\t\t\treturn -1;\r\n\r\n\t\tfor (i = 0; jmod[i].opt != NULL; i++)\r\n\t\t\tif (strcmp(tok, jmod[i].opt) == 0) {\r\n\t\t\t\treport[3] = (report[3] & 0xF0) | jmod[i].val;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tif (jmod[i].opt != NULL)\r\n\t\t\tcontinue;\r\n\r\n\t\tif (!(tok[0] == '-' && tok[1] == '-') && mvt < 3) {\r\n\t\t\terrno = 0;\r\n\t\t\treport[mvt++] = (char)strtol(tok, NULL, 0);\r\n\t\t\tif (errno != 0) {\r\n\t\t\t\tfprintf(stderr, \"Bad value:'%s'\\n\", tok);\r\n\t\t\t\treport[mvt--] = 0;\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tfprintf(stderr, \"unknown option: %s\\n\", tok);\r\n\t}\r\n\treturn 4;\r\n}\r\n\r\nvoid print_options(char c)\r\n{\r\n\tint i = 0;\r\n\r\n\tif (c == 'k') {\r\n\t\tprintf(\"\tkeyboard options:\\n\"\r\n\t\t       \"\t\t--hold\\n\");\r\n\t\tfor (i = 0; kmod[i].opt != NULL; i++)\r\n\t\t\tprintf(\"\\t\\t%s\\n\", kmod[i].opt);\r\n\t\tprintf(\"\\n\tkeyboard values:\\n\"\r\n\t\t       \"\t\t[a-z] or\\n\");\r\n\t\tfor (i = 0; kval[i].opt != NULL; i++)\r\n\t\t\tprintf(\"\\t\\t%-8s%s\", kval[i].opt, i % 2 ? \"\\n\" : \"\");\r\n\t\tprintf(\"\\n\");\r\n\t} else if (c == 'm') {\r\n\t\tprintf(\"\tmouse options:\\n\"\r\n\t\t       \"\t\t--hold\\n\");\r\n\t\tfor (i = 0; mmod[i].opt != NULL; i++)\r\n\t\t\tprintf(\"\\t\\t%s\\n\", mmod[i].opt);\r\n\t\tprintf(\"\\n\tmouse values:\\n\"\r\n\t\t       \"\t\tTwo signed numbers\\n\"\r\n\t\t       \"--quit to close\\n\");\r\n\t} else {\r\n\t\tprintf(\"\tjoystick options:\\n\");\r\n\t\tfor (i = 0; jmod[i].opt != NULL; i++)\r\n\t\t\tprintf(\"\\t\\t%s\\n\", jmod[i].opt);\r\n\t\tprintf(\"\\n\tjoystick values:\\n\"\r\n\t\t       \"\t\tthree signed numbers\\n\"\r\n\t\t       \"--quit to close\\n\");\r\n\t}\r\n}\r\n\r\nint main(int argc, const char *argv[])\r\n{\r\n\tconst char *filename = NULL;\r\n\tint fd = 0;\r\n\tchar buf[BUF_LEN];\r\n\tint cmd_len;\r\n\tchar report[8];\r\n\tint to_send = 8;\r\n\tint hold = 0;\r\n\tfd_set rfds;\r\n\tint retval, i;\r\n\r\n\tif (argc < 3) {\r\n\t\tfprintf(stderr, \"Usage: %s devname mouse|keyboard|joystick\\n\",\r\n\t\t\targv[0]);\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tif (argv[2][0] != 'k' && argv[2][0] != 'm' && argv[2][0] != 'j')\r\n\t  return 2;\r\n\r\n\tfilename = argv[1];\r\n\r\n\tif ((fd = open(filename, O_RDWR, 0666)) == -1) {\r\n\t\tperror(filename);\r\n\t\treturn 3;\r\n\t}\r\n\r\n\tprint_options(argv[2][0]);\r\n\r\n\twhile (42) {\r\n\r\n\t\tFD_ZERO(&rfds);\r\n\t\tFD_SET(STDIN_FILENO, &rfds);\r\n\t\tFD_SET(fd, &rfds);\r\n\r\n\t\tretval = select(fd + 1, &rfds, NULL, NULL, NULL);\r\n\t\tif (retval == -1 && errno == EINTR)\r\n\t\t\tcontinue;\r\n\t\tif (retval < 0) {\r\n\t\t\tperror(\"select()\");\r\n\t\t\treturn 4;\r\n\t\t}\r\n\r\n\t\tif (FD_ISSET(fd, &rfds)) {\r\n\t\t\tcmd_len = read(fd, buf, BUF_LEN - 1);\r\n\t\t\tprintf(\"recv report:\");\r\n\t\t\tfor (i = 0; i < cmd_len; i++)\r\n\t\t\t\tprintf(\" %02x\", buf[i]);\r\n\t\t\tprintf(\"\\n\");\r\n\t\t}\r\n\r\n\t\tif (FD_ISSET(STDIN_FILENO, &rfds)) {\r\n\t\t\tmemset(report, 0x0, sizeof(report));\r\n\t\t\tcmd_len = read(STDIN_FILENO, buf, BUF_LEN - 1);\r\n\r\n\t\t\tif (cmd_len == 0)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tbuf[cmd_len - 1] = '\\0';\r\n\t\t\thold = 0;\r\n\r\n\t\t\tmemset(report, 0x0, sizeof(report));\r\n\t\t\tif (argv[2][0] == 'k')\r\n\t\t\t\tto_send = keyboard_fill_report(report, buf, &hold);\r\n\t\t\telse if (argv[2][0] == 'm')\r\n\t\t\t\tto_send = mouse_fill_report(report, buf, &hold);\r\n\t\t\telse\r\n\t\t\t\tto_send = joystick_fill_report(report, buf, &hold);\r\n\r\n\t\t\tif (to_send == -1)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tif (write(fd, report, to_send) != to_send) {\r\n\t\t\t\tperror(filename);\r\n\t\t\t\treturn 5;\r\n\t\t\t}\r\n\t\t\tif (!hold) {\r\n\t\t\t\tmemset(report, 0x0, sizeof(report));\r\n\t\t\t\tif (write(fd, report, to_send) != to_send) {\r\n\t\t\t\t\tperror(filename);\r\n\t\t\t\t\treturn 6;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tclose(fd);\r\n\treturn 0;\r\n}\r\n```\r\n\r\n###Source\r\nhttps://www.kernel.org/doc/Documentation/usb/gadget_hid.txt\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}